---
phase: 03-architecture-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - scraper.py
  - config/filter-config.json
autonomous: true

must_haves:
  truths:
    - "Filter returns a numeric score, not just True/False"
    - "Each matched signal contributes points to the total score"
    - "Threshold for qualification is configurable in JSON"
    - "Scoring reasons are tracked and returned"
  artifacts:
    - path: "scraper.py"
      provides: "ScoringResult dataclass, score_job() function"
      contains: "ScoringResult"
    - path: "scraper.py"
      provides: "Backward-compatible wrapper"
      contains: "def description_matches"
  key_links:
    - from: "scraper.py"
      to: "config/filter-config.json"
      via: "weights from positive_signals"
      pattern: "weight.*positive_signals"
    - from: "description_matches"
      to: "score_job"
      via: "wrapper calls scorer"
      pattern: "score_job.*qualified"
---

<objective>
Convert the boolean tier filter to a weighted scoring system that returns score + reasons.

Purpose: Satisfy ARCH-02 (weighted scoring) and ARCH-04 (returns score + reasons) - enables confidence levels and debugging of filter decisions.
Output: ScoringResult dataclass, score_job() function, updated description_matches() as wrapper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-architecture-refactoring/03-RESEARCH.md
@.planning/phases/03-architecture-refactoring/03-01-SUMMARY.md

@scraper.py (after Plan 01 - has config loading)
@config/filter-config.json (created in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScoringResult dataclass</name>
  <files>scraper.py</files>
  <action>
Add ScoringResult dataclass after imports in scraper.py:

```python
from dataclasses import dataclass, field

@dataclass
class ScoringResult:
    """Result of scoring a job posting.

    Attributes:
        score: Total numeric score (higher = better match)
        qualified: Whether score meets threshold
        reasons: List of human-readable scoring explanations
        threshold: The threshold used for qualification
    """
    score: float
    qualified: bool
    reasons: list[str] = field(default_factory=list)
    threshold: float = 50.0
```

This dataclass will be used by score_job() and returned to callers who want detailed scoring information.
  </action>
  <verify>
Python syntax check: `python -c "from scraper import ScoringResult; print(ScoringResult(50.0, True))"`
  </verify>
  <done>ScoringResult dataclass defined with score, qualified, reasons, threshold fields</done>
</task>

<task type="auto">
  <name>Task 2: Implement score_job() function</name>
  <files>scraper.py</files>
  <action>
Create new score_job() function that implements weighted scoring logic:

```python
def score_job(description: str, company_name: str = None, config: dict = None) -> ScoringResult:
    """Score a job posting and return detailed results.

    Args:
        description: Job description text
        company_name: Optional company name for blocklist check
        config: Optional config dict (uses get_config() if not provided)

    Returns:
        ScoringResult with score, qualified flag, and reasons list
    """
    if config is None:
        config = get_config()

    threshold = config.get("threshold", 50.0)
    reasons = []
    score = 0.0

    # Company blocklist check FIRST (immediate disqualification)
    if company_name:
        company_lower = company_name.lower()
        for blocked in config["company_blocklist"]:
            if blocked in company_lower:
                return ScoringResult(
                    score=-100.0,
                    qualified=False,
                    reasons=[f"Company '{company_name}' in blocklist ({blocked})"],
                    threshold=threshold
                )

    # No description = cannot qualify
    if not description or pd.isna(description):
        return ScoringResult(
            score=0.0,
            qualified=False,
            reasons=["No description provided"],
            threshold=threshold
        )

    desc_lower = description.lower()

    # Required context check (solar/PV)
    required = config["required_context"]["patterns"]
    has_required = any(p in desc_lower for p in required)
    if not has_required:
        return ScoringResult(
            score=0.0,
            qualified=False,
            reasons=["Missing required solar/PV context"],
            threshold=threshold
        )
    reasons.append("+0: Has solar/PV context (required)")

    # Check all exclusions (any match = immediate -100)
    for name, excl in config["exclusions"].items():
        for pattern in excl["patterns"]:
            if pattern in desc_lower:
                return ScoringResult(
                    score=-100.0,
                    qualified=False,
                    reasons=[f"Excluded: {excl['description']} (matched '{pattern}')"],
                    threshold=threshold
                )

    # Check design role indicators (used by multiple tiers)
    design_indicators = config["design_role_indicators"]
    has_design_role = any(ind in desc_lower for ind in design_indicators)

    # Score positive signals
    signals = config["positive_signals"]

    # Tier 1: Solar-specific tools (auto-qualify)
    tier1 = signals["tier1_tools"]
    for pattern in tier1["patterns"]:
        if pattern in desc_lower:
            score += tier1["weight"]
            reasons.append(f"+{tier1['weight']}: {tier1['description']} ({pattern})")
            break  # Only count once per tier

    # Tier 2: Strong technical signals (require design role)
    tier2 = signals["tier2_strong"]
    if has_design_role:
        for pattern in tier2["patterns"]:
            if pattern in desc_lower:
                score += tier2["weight"]
                reasons.append(f"+{tier2['weight']}: {tier2['description']} ({pattern})")
                break

    # Tier 3: CAD + project type + design role
    tier3 = signals["tier3_cad_project"]
    if has_design_role:
        has_cad = any(p in desc_lower for p in tier3["patterns_cad"])
        has_project = any(p in desc_lower for p in tier3["patterns_project"])
        if has_cad and has_project:
            score += tier3["weight"]
            reasons.append(f"+{tier3['weight']}: {tier3['description']}")

    # Tier 4: Title signals (check first 200 chars)
    tier4 = signals["tier4_title"]
    title_area = desc_lower[:200]
    for pattern in tier4["patterns"]:
        if pattern in title_area:
            score += tier4["weight"]
            reasons.append(f"+{tier4['weight']}: {tier4['description']} ({pattern})")
            break

    # Tier 5: CAD + design role (simpler)
    tier5 = signals["tier5_cad_design"]
    if has_design_role:
        has_cad = any(p in desc_lower for p in tier5["patterns_cad"])
        if has_cad:
            score += tier5["weight"]
            reasons.append(f"+{tier5['weight']}: {tier5['description']}")

    # Tier 6: Design role titles
    tier6 = signals["tier6_design_titles"]
    for pattern in tier6["patterns"]:
        if pattern in desc_lower:
            score += tier6["weight"]
            reasons.append(f"+{tier6['weight']}: {tier6['description']} ({pattern})")
            break

    # Add design role indicator note
    if has_design_role:
        reasons.append("+0: Has design role indicator")

    return ScoringResult(
        score=score,
        qualified=score >= threshold,
        reasons=reasons,
        threshold=threshold
    )
```

Key behaviors:
- Blocklist and exclusions return score=-100 (hard disqualification)
- Each tier adds its weight to the score
- Tiers that require design_role check that condition first
- Reasons list explains every scoring decision
- Threshold from config determines qualified=True/False
  </action>
  <verify>
Test scoring:
```python
python -c "
from scraper import score_job
result = score_job('Solar Designer needed. AutoCAD, Helioscope, permit sets.')
print(f'Score: {result.score}, Qualified: {result.qualified}')
print('Reasons:', result.reasons)
"
```
Expected: Score > threshold, Qualified=True, multiple reasons listed
  </verify>
  <done>score_job() function returns ScoringResult with weighted scoring and reasons</done>
</task>

<task type="auto">
  <name>Task 3: Update description_matches() as backward-compatible wrapper</name>
  <files>scraper.py</files>
  <action>
Replace the current description_matches() implementation with a thin wrapper:

```python
def description_matches(description: str, company_name: str = None) -> bool:
    """Check if job description matches solar design criteria.

    DEPRECATED: Use score_job() for detailed scoring information.
    This wrapper maintains backward compatibility with evaluate.py.

    Args:
        description: Job description text
        company_name: Optional company name for blocklist check

    Returns:
        True if job qualifies, False otherwise
    """
    result = score_job(description, company_name)
    return result.qualified
```

This preserves the existing API for evaluate.py while delegating to the new scoring system.

CRITICAL: The old description_matches() body should be removed entirely. All logic now lives in score_job().
  </action>
  <verify>
Run evaluation: `python evaluate.py --golden`
Expected: 100% precision, 75% recall (identical to Plan 01 results)
  </verify>
  <done>description_matches() is thin wrapper around score_job(), evaluate.py passes unchanged</done>
</task>

</tasks>

<verification>
1. `python evaluate.py --golden` shows 100% precision, 75% recall (no regression)
2. `score_job()` returns ScoringResult with score, qualified, reasons
3. `description_matches()` calls score_job() and returns qualified boolean
4. Weights come from config file (modifying config changes scores)
5. Threshold is configurable (changing threshold changes qualified status)
</verification>

<success_criteria>
- ARCH-02 satisfied: Tiered boolean filter converted to weighted scoring
- ARCH-04 satisfied: Filter returns score + reasons (via ScoringResult)
- No regression in evaluate.py metrics
- Threshold is configurable in filter-config.json
- Each tier contributes weighted points, not just True/False
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-refactoring/03-02-SUMMARY.md`
</output>
