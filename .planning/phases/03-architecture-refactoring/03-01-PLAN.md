---
phase: 03-architecture-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - config/filter-config.json
  - scraper.py
autonomous: true

must_haves:
  truths:
    - "Filter terms live in JSON file, not hardcoded in Python"
    - "Changing a filter term requires editing JSON only, no Python changes"
    - "scraper.py loads configuration from JSON at runtime"
  artifacts:
    - path: "config/filter-config.json"
      provides: "All filter terms and weights"
      contains: "company_blocklist"
    - path: "scraper.py"
      provides: "Config loading and term lookup"
      contains: "load_filter_config"
  key_links:
    - from: "scraper.py"
      to: "config/filter-config.json"
      via: "json.load in load_filter_config()"
      pattern: "json\\.load.*filter-config"
---

<objective>
Extract all hardcoded filter terms from scraper.py to an external JSON configuration file.

Purpose: Satisfy ARCH-01 (externalized configuration) - enables non-developers to tune filter terms without code changes.
Output: `config/filter-config.json` containing all term lists, `scraper.py` modified to load from config.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-architecture-refactoring/03-RESEARCH.md

@scraper.py (current implementation with hardcoded terms)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON configuration file</name>
  <files>config/filter-config.json</files>
  <action>
Create directory `config/` and file `config/filter-config.json` containing all filter terms extracted from scraper.py:

```json
{
  "version": "1.0",
  "threshold": 50.0,

  "company_blocklist": [
    "boeing", "northrop grumman", "lockheed", "lockheed martin",
    "raytheon", "spacex", "blue origin", "general dynamics",
    "bae systems", "l3harris", "leidos", "huntington ingalls",
    "rtx", "rtx corporation", "sierra nevada corporation",
    "intel", "nvidia", "amd", "qualcomm", "broadcom",
    "texas instruments", "micron", "applied materials",
    "lam research", "kla", "asml", "marvell", "microchip"
  ],

  "required_context": {
    "patterns": ["solar", "pv", "photovoltaic"],
    "description": "Must have solar/PV context to qualify"
  },

  "exclusions": {
    "tennis": {
      "patterns": ["tennis", "racquet", "racket", "pickleball", "badminton"],
      "description": "Tennis stringing false positives"
    },
    "space": {
      "patterns": ["spacecraft", "satellite", "space system", "aerospace", "starlink", "orbit", "launch vehicle", "avionics", "space exploration"],
      "description": "Spacecraft solar panels"
    },
    "semiconductor": {
      "patterns": ["semiconductor", "rtl", "asic", "fpga", "vlsi", "chip design", "physical verification", "synthesis", "place and route", "foundry", "wafer", "silicon", "integrated circuit", "ic design"],
      "description": "Chip design industry"
    },
    "eda_tools": {
      "patterns": ["cadence", "synopsys", "mentor graphics", "siemens eda", "virtuoso", "spectre", "innovus", "genus", "conformal", "calibre", "questa", "modelsim", "vcs", "verdi", "primetime", "icc2", "design compiler", "dc shell", "spyglass", "formality", "encounter", "ic compiler"],
      "description": "EDA chip design tools"
    },
    "installer": {
      "patterns": ["installer", "installation technician", "roof lead", "rooftop", "journeyman electrician", "apprentice electrician", "lineman", "lineworker", "o&m technician", "field technician", "service technician", "field service", "commissioning technician", "maintenance technician", "solar technician", "pv technician", "array supervisor", "stringer", "roofer", "foreman", "crew lead", "panel installer"],
      "description": "Field installation roles"
    },
    "sales": {
      "patterns": ["sales director", "sales manager", "marketing director", "marketing manager", "account executive", "business development", "sales representative", "sales team", "sales & marketing", "sales and marketing", "sales consultant", "sales engineer", "sales specialist", "account manager", "territory manager"],
      "description": "Sales and marketing roles"
    },
    "management": {
      "patterns": ["project manager", "construction manager", "operations manager", "program manager", "development manager", "site manager", "general manager", "director of operations", "vp ", "vice president", "chief ", "ceo", "cto", "cfo"],
      "description": "Management roles"
    },
    "other_engineering": {
      "patterns": ["application engineer", "applications engineer", "technical sales", "technical support", "field engineer", "commissioning engineer", "product engineer", "project engineer", "construction engineer", "site engineer", "structural engineer", "civil engineer", "mechanical engineer", "manufacturing engineer", "process engineer", "quality engineer", "systems engineer", "transmission engineer", "substation engineer", "protection and control", "p&c engineer", "relay engineer", "estimator", "preconstruction", "interconnection engineer", "grid engineer", "protection engineer", "metering engineer"],
      "description": "Non-design engineering roles"
    }
  },

  "positive_signals": {
    "tier1_tools": {
      "patterns": ["helioscope", "aurora solar", "pvsyst", "solaredge designer", "opensolaris"],
      "weight": 100,
      "description": "Solar-specific design tools - auto-qualify"
    },
    "tier2_strong": {
      "patterns": ["string sizing", "stringing diagram", "stringing layout", "module layout", "array layout", "panel layout", "single line diagram", "one-line diagram", "sld ", "conduit schedule", "wiring schedule", "wire schedule", "permit set", "plan set", "permit package", "construction drawing", "voltage drop calculation", "voltage drop calc"],
      "weight": 60,
      "requires": "design_role",
      "description": "Strong technical signals requiring design role"
    },
    "tier3_cad_project": {
      "patterns_cad": ["autocad", "auto cad", "revit", "sketchup", "bluebeam", "solidworks"],
      "patterns_project": ["solar array", "pv array", "solar installation", "pv installation", "solar project", "pv project", "solar system", "pv system", "residential solar", "commercial solar", "utility solar", "utility-scale solar", "rooftop solar", "ground mount solar", "carport solar"],
      "weight": 40,
      "requires": "design_role",
      "description": "General CAD + design role + solar project type"
    },
    "tier4_title": {
      "patterns": ["solar designer", "pv designer", "solar drafter", "pv drafter", "solar design engineer", "pv design engineer", "solar cad", "photovoltaic designer", "solar design technician"],
      "weight": 80,
      "check_area": "title",
      "description": "Explicit solar design job titles"
    },
    "tier5_cad_design": {
      "patterns_cad": ["autocad", "auto cad", "revit", "sketchup", "bluebeam", "solidworks"],
      "weight": 30,
      "requires": "design_role",
      "description": "CAD tool + design role (with solar context from required_context)"
    },
    "tier6_design_titles": {
      "patterns": ["electrical designer", "electrical drafter", "cad designer", "cad drafter", "cad technician", "cad operator", "design technician", "drafting technician", "bim modeler", "bim technician", "design assistant", "permit designer"],
      "weight": 20,
      "description": "Design role titles with solar context"
    }
  },

  "design_role_indicators": ["designer", "drafter", "draftsman", "drafting", "cad ", "design engineer", "design technician", "cad technician"]
}
```

Use pathlib for path handling. File location: relative to scraper.py parent directory.
  </action>
  <verify>
File exists: `test -f config/filter-config.json`
Valid JSON: `python -c "import json; json.load(open('config/filter-config.json'))"`
  </verify>
  <done>config/filter-config.json exists with all terms from scraper.py, valid JSON structure</done>
</task>

<task type="auto">
  <name>Task 2: Add config loading to scraper.py</name>
  <files>scraper.py</files>
  <action>
Add configuration loading function and modify description_matches() to use config:

1. Add imports at top:
```python
import json
```

2. Add config loading function after COMPANY_BLOCKLIST (keep COMPANY_BLOCKLIST for now as fallback):
```python
def load_filter_config(config_path: Path = None) -> dict:
    """Load filter configuration from JSON file.

    Args:
        config_path: Path to config file. Defaults to config/filter-config.json
                     relative to this file's location.

    Returns:
        Configuration dictionary with signals, weights, and threshold.
    """
    if config_path is None:
        config_path = Path(__file__).parent / "config" / "filter-config.json"

    with open(config_path, encoding="utf-8") as f:
        return json.load(f)


# Load config at module level (lazy loading on first use)
_CONFIG = None

def get_config() -> dict:
    """Get filter configuration, loading from file if needed."""
    global _CONFIG
    if _CONFIG is None:
        _CONFIG = load_filter_config()
    return _CONFIG
```

3. Modify description_matches() to load terms from config instead of hardcoded lists:
- Replace COMPANY_BLOCKLIST lookup with `config["company_blocklist"]`
- Replace each hardcoded term list with lookup from config
- Keep the same boolean logic structure (tier system) for now - scoring comes in Plan 02

4. Keep COMPANY_BLOCKLIST constant as documentation but use config in actual code.

IMPORTANT: Maintain backward compatibility - description_matches() signature stays the same: `(description: str, company_name: str = None) -> bool`
  </action>
  <verify>
Run evaluation: `python evaluate.py --golden`
Expected: Same results as before (100% precision, 75% recall) - no regression
  </verify>
  <done>scraper.py loads terms from config file, evaluate.py passes with identical metrics</done>
</task>

<task type="auto">
  <name>Task 3: Verify config changes work without code changes</name>
  <files>config/filter-config.json</files>
  <action>
Verify that ARCH-01 is satisfied by testing config-only changes:

1. Add a test term to config that would be excluded (e.g., add "testing123" to tennis patterns)
2. Run evaluate.py - should pass (test term doesn't appear in golden set)
3. Remove the test term
4. Verify evaluate.py still passes

This confirms that filter behavior can be modified by editing JSON alone.

Document this verification in the commit message.
  </action>
  <verify>
Run: `python evaluate.py --golden`
Metrics unchanged: 100% precision, 75% recall
  </verify>
  <done>Config changes affect filter behavior without Python code changes - ARCH-01 satisfied</done>
</task>

</tasks>

<verification>
1. `config/filter-config.json` exists with all term lists from scraper.py
2. `python evaluate.py --golden` shows 100% precision, 75% recall (no regression)
3. `scraper.py` contains `load_filter_config()` function
4. Filter terms are read from JSON at runtime, not hardcoded
</verification>

<success_criteria>
- ARCH-01 requirement satisfied: Filter configuration externalized to JSON
- No regression in filter behavior (evaluate.py passes with same metrics)
- Config file is valid JSON and contains all term categories
- scraper.py loads config using pathlib for cross-platform paths
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-refactoring/03-01-SUMMARY.md`
</output>
