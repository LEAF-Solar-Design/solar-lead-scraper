---
phase: 03-architecture-refactoring
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - scraper.py
  - config/filter-config.json
autonomous: true

must_haves:
  truths:
    - "Company scoring is a separate function from role scoring"
    - "ScoringResult includes company_score and role_score separately"
    - "Company signals can be tuned independently of role signals"
  artifacts:
    - path: "scraper.py"
      provides: "score_company() and score_role() functions"
      contains: "def score_company"
    - path: "scraper.py"
      provides: "Updated ScoringResult with separated scores"
      contains: "company_score"
    - path: "config/filter-config.json"
      provides: "Separated company and role sections"
      contains: "company_signals"
  key_links:
    - from: "score_job"
      to: "score_company"
      via: "function call"
      pattern: "score_company.*company_name"
    - from: "score_job"
      to: "score_role"
      via: "function call"
      pattern: "score_role.*description"
---

<objective>
Separate company classification from role/description classification into distinct functions.

Purpose: Satisfy ARCH-03 (separated company and role classification) - enables independent tuning of company-level vs role-level signals, better debugging of which dimension caused qualification/rejection.
Output: score_company() and score_role() functions, updated ScoringResult, reorganized config.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-architecture-refactoring/03-RESEARCH.md
@.planning/phases/03-architecture-refactoring/03-02-SUMMARY.md

@scraper.py (after Plan 02 - has score_job() and ScoringResult)
@config/filter-config.json (after Plan 02 - has weighted signals)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ScoringResult to include separated scores</name>
  <files>scraper.py</files>
  <action>
Update the ScoringResult dataclass to track company and role scores separately:

```python
@dataclass
class ScoringResult:
    """Result of scoring a job posting.

    Attributes:
        score: Total numeric score (company_score + role_score)
        qualified: Whether score meets threshold
        reasons: List of human-readable scoring explanations
        company_score: Points from company-level signals (blocklist, known companies)
        role_score: Points from role/description signals (tools, titles, etc.)
        threshold: The threshold used for qualification
    """
    score: float
    qualified: bool
    reasons: list[str] = field(default_factory=list)
    company_score: float = 0.0
    role_score: float = 0.0
    threshold: float = 50.0
```

This change is additive - existing code that ignores company_score/role_score will still work.
  </action>
  <verify>
Python syntax check: `python -c "from scraper import ScoringResult; r = ScoringResult(50, True); print(r.company_score, r.role_score)"`
  </verify>
  <done>ScoringResult includes company_score and role_score fields with defaults</done>
</task>

<task type="auto">
  <name>Task 2: Create score_company() and score_role() functions</name>
  <files>scraper.py</files>
  <action>
Extract company and role scoring into separate functions:

```python
def score_company(company_name: str, config: dict) -> tuple[float, list[str]]:
    """Score based on company signals only.

    Args:
        company_name: Company name to check
        config: Configuration dictionary

    Returns:
        Tuple of (score, reasons_list)
        Score is -100 if blocklisted, 0 otherwise (future: positive signals for known solar companies)
    """
    if not company_name:
        return (0.0, [])

    company_lower = company_name.lower()

    # Blocklist check
    for blocked in config["company_blocklist"]:
        if blocked in company_lower:
            return (-100.0, [f"Company '{company_name}' in blocklist ({blocked})"])

    # Future: Add positive company signals here (known solar companies)
    # e.g., config.get("company_positive_signals", [])

    return (0.0, [])


def score_role(description: str, config: dict) -> tuple[float, list[str]]:
    """Score based on role/description signals only.

    Args:
        description: Job description text
        config: Configuration dictionary

    Returns:
        Tuple of (score, reasons_list)
        Score is sum of matched positive signals, -100 if exclusion matched
    """
    if not description or pd.isna(description):
        return (0.0, ["No description provided"])

    desc_lower = description.lower()
    reasons = []
    score = 0.0

    # Required context check (solar/PV)
    required = config["required_context"]["patterns"]
    has_required = any(p in desc_lower for p in required)
    if not has_required:
        return (0.0, ["Missing required solar/PV context"])
    reasons.append("+0: Has solar/PV context (required)")

    # Check all exclusions (any match = immediate -100)
    for name, excl in config["exclusions"].items():
        for pattern in excl["patterns"]:
            if pattern in desc_lower:
                return (-100.0, [f"Excluded: {excl['description']} (matched '{pattern}')"])

    # Check design role indicators (used by multiple tiers)
    design_indicators = config["design_role_indicators"]
    has_design_role = any(ind in desc_lower for ind in design_indicators)

    # Score positive signals
    signals = config["positive_signals"]

    # Tier 1: Solar-specific tools
    tier1 = signals["tier1_tools"]
    for pattern in tier1["patterns"]:
        if pattern in desc_lower:
            score += tier1["weight"]
            reasons.append(f"+{tier1['weight']}: {tier1['description']} ({pattern})")
            break

    # Tier 2: Strong technical signals
    tier2 = signals["tier2_strong"]
    if has_design_role:
        for pattern in tier2["patterns"]:
            if pattern in desc_lower:
                score += tier2["weight"]
                reasons.append(f"+{tier2['weight']}: {tier2['description']} ({pattern})")
                break

    # Tier 3: CAD + project type + design role
    tier3 = signals["tier3_cad_project"]
    if has_design_role:
        has_cad = any(p in desc_lower for p in tier3["patterns_cad"])
        has_project = any(p in desc_lower for p in tier3["patterns_project"])
        if has_cad and has_project:
            score += tier3["weight"]
            reasons.append(f"+{tier3['weight']}: {tier3['description']}")

    # Tier 4: Title signals
    tier4 = signals["tier4_title"]
    title_area = desc_lower[:200]
    for pattern in tier4["patterns"]:
        if pattern in title_area:
            score += tier4["weight"]
            reasons.append(f"+{tier4['weight']}: {tier4['description']} ({pattern})")
            break

    # Tier 5: CAD + design role
    tier5 = signals["tier5_cad_design"]
    if has_design_role:
        has_cad = any(p in desc_lower for p in tier5["patterns_cad"])
        if has_cad:
            score += tier5["weight"]
            reasons.append(f"+{tier5['weight']}: {tier5['description']}")

    # Tier 6: Design role titles
    tier6 = signals["tier6_design_titles"]
    for pattern in tier6["patterns"]:
        if pattern in desc_lower:
            score += tier6["weight"]
            reasons.append(f"+{tier6['weight']}: {tier6['description']} ({pattern})")
            break

    if has_design_role:
        reasons.append("+0: Has design role indicator")

    return (score, reasons)
```

These functions encapsulate the scoring logic for their respective domains.
  </action>
  <verify>
Test separation:
```python
python -c "
from scraper import score_company, score_role, get_config
config = get_config()
c_score, c_reasons = score_company('Boeing Defense', config)
print(f'Company score: {c_score}, reasons: {c_reasons}')
r_score, r_reasons = score_role('Solar Designer using Helioscope', config)
print(f'Role score: {r_score}, reasons: {r_reasons}')
"
```
  </verify>
  <done>score_company() and score_role() are separate functions with distinct responsibilities</done>
</task>

<task type="auto">
  <name>Task 3: Update score_job() to use separated functions</name>
  <files>scraper.py</files>
  <action>
Refactor score_job() to delegate to score_company() and score_role():

```python
def score_job(description: str, company_name: str = None, config: dict = None) -> ScoringResult:
    """Score a job posting and return detailed results.

    Combines company-level and role-level scoring into a single result.

    Args:
        description: Job description text
        company_name: Optional company name for blocklist check
        config: Optional config dict (uses get_config() if not provided)

    Returns:
        ScoringResult with total score, company_score, role_score, and reasons
    """
    if config is None:
        config = get_config()

    threshold = config.get("threshold", 50.0)

    # Score company separately
    company_score, company_reasons = score_company(company_name, config)

    # If company is blocklisted, short-circuit
    if company_score < 0:
        return ScoringResult(
            score=company_score,
            qualified=False,
            reasons=company_reasons,
            company_score=company_score,
            role_score=0.0,
            threshold=threshold
        )

    # Score role/description
    role_score, role_reasons = score_role(description, config)

    # If role is excluded, short-circuit
    if role_score < 0:
        return ScoringResult(
            score=role_score,
            qualified=False,
            reasons=role_reasons,
            company_score=company_score,
            role_score=role_score,
            threshold=threshold
        )

    # Combine scores
    total_score = company_score + role_score
    all_reasons = company_reasons + role_reasons

    return ScoringResult(
        score=total_score,
        qualified=total_score >= threshold,
        reasons=all_reasons,
        company_score=company_score,
        role_score=role_score,
        threshold=threshold
    )
```

The orchestration in score_job() is now thin - it calls the specialized functions and combines results.
  </action>
  <verify>
Run full evaluation: `python evaluate.py --golden`
Expected: 100% precision, 75% recall (no regression)

Test separated scores:
```python
python -c "
from scraper import score_job
result = score_job('Solar Designer using Helioscope and AutoCAD for permit sets', 'SunPower Solar')
print(f'Total: {result.score}, Company: {result.company_score}, Role: {result.role_score}')
print(f'Qualified: {result.qualified}')
"
```
  </verify>
  <done>score_job() delegates to score_company() and score_role(), populates company_score and role_score in result</done>
</task>

</tasks>

<verification>
1. `python evaluate.py --golden` shows 100% precision, 75% recall (no regression)
2. `ScoringResult` has `company_score` and `role_score` fields
3. `score_company()` handles company blocklist and returns (score, reasons)
4. `score_role()` handles all role/description signals and returns (score, reasons)
5. `score_job()` combines both scores and tracks them separately
6. Company and role signals can be tuned independently in config
</verification>

<success_criteria>
- ARCH-03 satisfied: Company classification separated from role classification
- No regression in evaluate.py metrics
- ScoringResult.company_score and ScoringResult.role_score are populated correctly
- score_company() and score_role() can be tested/tuned independently
- Callers can inspect which dimension caused qualification/rejection
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-refactoring/03-03-SUMMARY.md`
</output>
